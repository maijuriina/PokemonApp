{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Maijuriina/PokemonApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { BerryClient } from 'pokenode-ts';\nimport { PokemonClient } from 'pokenode-ts';\nimport { Pokemon } from '../item/pokemon';\nimport { of } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport let ConfigService = /*#__PURE__*/(() => {\n  class ConfigService {\n    constructor(http) {\n      this.http = http;\n      const api = new BerryClient({\n        cacheOptions: {\n          maxAge: 5000,\n          exclude: {\n            query: false\n          }\n        }\n      }); // Enable cache with 5 seconds including requests with query parameters.\n      // First call will cache the response\n      // The next calls within 5 seconds will come from the cache\n    }\n\n    getPokemonList() {\n      var griddedPokemons = [];\n\n      _asyncToGenerator(function* () {\n        const api = new PokemonClient();\n        var amountOfPokemons = 898; // amount of pokemon without counting variations\n\n        var amountWanted = 20;\n        yield api.listPokemons(0, amountOfPokemons).then(data => {\n          var indexArray = new Array();\n\n          for (var i = 1; i <= amountWanted; i++) {\n            var randomPokemonIndex = Math.floor(Math.random() * amountOfPokemons);\n\n            if (indexArray.includes(randomPokemonIndex)) {\n              // if index is already in array, it is not added and random is made again\n              console.log(randomPokemonIndex);\n              i--;\n              continue;\n            } else {\n              // if index is not in array, it is used to push data result to griddedPokemons\n              indexArray.push(randomPokemonIndex);\n              const pokemon = Object.assign(new Pokemon(), data.results[randomPokemonIndex]); // make data into a Pokemon\n\n              griddedPokemons.push(pokemon); // push into Pokemon-list to be returned at the end of the api call\n            }\n          }\n        }).catch(error => console.error(error));\n      })();\n\n      for (var i = 1; i <= griddedPokemons.length; i++) {\n        griddedPokemons[i].hp = this.getHP(griddedPokemons[i].name);\n      }\n\n      return of(griddedPokemons);\n    }\n\n    getPokemonByName(searchTerm) {\n      _asyncToGenerator(function* () {\n        const api = new PokemonClient();\n        yield api.getPokemonByName(searchTerm).then(data => console.log(data.name)) // will output name in searchTerm\n        .catch(error => console.error(error));\n      })();\n    }\n\n    getHP(name) {\n      var hp;\n\n      _asyncToGenerator(function* () {\n        const api = new PokemonClient();\n        yield api.getPokemonByName(name).then(data => hp = data.stats[0].base_stat) // fetch HP of pokemon\n        .catch(error => console.error(error));\n      })();\n\n      return hp;\n    }\n\n  }\n\n  ConfigService.ɵfac = function ConfigService_Factory(t) {\n    return new (t || ConfigService)(i0.ɵɵinject(i1.HttpClient));\n  };\n\n  ConfigService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: ConfigService,\n    factory: ConfigService.ɵfac,\n    providedIn: 'root' // fixes NullInjectorError\n\n  });\n  return ConfigService;\n})();","map":null,"metadata":{},"sourceType":"module"}