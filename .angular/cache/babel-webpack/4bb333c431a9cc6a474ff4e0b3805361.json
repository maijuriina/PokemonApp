{"ast":null,"code":"'use strict';\n\nconst format = require('quick-format-unescaped');\n\nmodule.exports = pino;\n\nconst _console = pfGlobalThisOrFallback().console || {};\n\nconst stdSerializers = {\n  mapHttpRequest: mock,\n  mapHttpResponse: mock,\n  wrapRequestSerializer: passthrough,\n  wrapResponseSerializer: passthrough,\n  wrapErrorSerializer: passthrough,\n  req: mock,\n  res: mock,\n  err: asErrValue\n};\n\nfunction shouldSerialize(serialize, serializers) {\n  if (Array.isArray(serialize)) {\n    const hasToFilter = serialize.filter(function (k) {\n      return k !== '!stdSerializers.err';\n    });\n    return hasToFilter;\n  } else if (serialize === true) {\n    return Object.keys(serializers);\n  }\n\n  return false;\n}\n\nfunction pino(opts) {\n  opts = opts || {};\n  opts.browser = opts.browser || {};\n  const transmit = opts.browser.transmit;\n\n  if (transmit && typeof transmit.send !== 'function') {\n    throw Error('pino: transmit option must have a send function');\n  }\n\n  const proto = opts.browser.write || _console;\n  if (opts.browser.write) opts.browser.asObject = true;\n  const serializers = opts.serializers || {};\n  const serialize = shouldSerialize(opts.browser.serialize, serializers);\n  let stdErrSerialize = opts.browser.serialize;\n  if (Array.isArray(opts.browser.serialize) && opts.browser.serialize.indexOf('!stdSerializers.err') > -1) stdErrSerialize = false;\n  const levels = ['error', 'fatal', 'warn', 'info', 'debug', 'trace'];\n\n  if (typeof proto === 'function') {\n    proto.error = proto.fatal = proto.warn = proto.info = proto.debug = proto.trace = proto;\n  }\n\n  if (opts.enabled === false) opts.level = 'silent';\n  const level = opts.level || 'info';\n  const logger = Object.create(proto);\n  if (!logger.log) logger.log = noop;\n  Object.defineProperty(logger, 'levelVal', {\n    get: getLevelVal\n  });\n  Object.defineProperty(logger, 'level', {\n    get: getLevel,\n    set: setLevel\n  });\n  const setOpts = {\n    transmit,\n    serialize,\n    asObject: opts.browser.asObject,\n    levels,\n    timestamp: getTimeFunction(opts)\n  };\n  logger.levels = pino.levels;\n  logger.level = level;\n  logger.setMaxListeners = logger.getMaxListeners = logger.emit = logger.addListener = logger.on = logger.prependListener = logger.once = logger.prependOnceListener = logger.removeListener = logger.removeAllListeners = logger.listeners = logger.listenerCount = logger.eventNames = logger.write = logger.flush = noop;\n  logger.serializers = serializers;\n  logger._serialize = serialize;\n  logger._stdErrSerialize = stdErrSerialize;\n  logger.child = child;\n  if (transmit) logger._logEvent = createLogEventShape();\n\n  function getLevelVal() {\n    return this.level === 'silent' ? Infinity : this.levels.values[this.level];\n  }\n\n  function getLevel() {\n    return this._level;\n  }\n\n  function setLevel(level) {\n    if (level !== 'silent' && !this.levels.values[level]) {\n      throw Error('unknown level ' + level);\n    }\n\n    this._level = level;\n    set(setOpts, logger, 'error', 'log'); // <-- must stay first\n\n    set(setOpts, logger, 'fatal', 'error');\n    set(setOpts, logger, 'warn', 'error');\n    set(setOpts, logger, 'info', 'log');\n    set(setOpts, logger, 'debug', 'log');\n    set(setOpts, logger, 'trace', 'log');\n  }\n\n  function child(bindings, childOptions) {\n    if (!bindings) {\n      throw new Error('missing bindings for child Pino');\n    }\n\n    childOptions = childOptions || {};\n\n    if (serialize && bindings.serializers) {\n      childOptions.serializers = bindings.serializers;\n    }\n\n    const childOptionsSerializers = childOptions.serializers;\n\n    if (serialize && childOptionsSerializers) {\n      var childSerializers = Object.assign({}, serializers, childOptionsSerializers);\n      var childSerialize = opts.browser.serialize === true ? Object.keys(childSerializers) : serialize;\n      delete bindings.serializers;\n      applySerializers([bindings], childSerialize, childSerializers, this._stdErrSerialize);\n    }\n\n    function Child(parent) {\n      this._childLevel = (parent._childLevel | 0) + 1;\n      this.error = bind(parent, bindings, 'error');\n      this.fatal = bind(parent, bindings, 'fatal');\n      this.warn = bind(parent, bindings, 'warn');\n      this.info = bind(parent, bindings, 'info');\n      this.debug = bind(parent, bindings, 'debug');\n      this.trace = bind(parent, bindings, 'trace');\n\n      if (childSerializers) {\n        this.serializers = childSerializers;\n        this._serialize = childSerialize;\n      }\n\n      if (transmit) {\n        this._logEvent = createLogEventShape([].concat(parent._logEvent.bindings, bindings));\n      }\n    }\n\n    Child.prototype = this;\n    return new Child(this);\n  }\n\n  return logger;\n}\n\npino.levels = {\n  values: {\n    fatal: 60,\n    error: 50,\n    warn: 40,\n    info: 30,\n    debug: 20,\n    trace: 10\n  },\n  labels: {\n    10: 'trace',\n    20: 'debug',\n    30: 'info',\n    40: 'warn',\n    50: 'error',\n    60: 'fatal'\n  }\n};\npino.stdSerializers = stdSerializers;\npino.stdTimeFunctions = Object.assign({}, {\n  nullTime,\n  epochTime,\n  unixTime,\n  isoTime\n});\n\nfunction set(opts, logger, level, fallback) {\n  const proto = Object.getPrototypeOf(logger);\n  logger[level] = logger.levelVal > logger.levels.values[level] ? noop : proto[level] ? proto[level] : _console[level] || _console[fallback] || noop;\n  wrap(opts, logger, level);\n}\n\nfunction wrap(opts, logger, level) {\n  if (!opts.transmit && logger[level] === noop) return;\n\n  logger[level] = function (write) {\n    return function LOG() {\n      const ts = opts.timestamp();\n      const args = new Array(arguments.length);\n      const proto = Object.getPrototypeOf && Object.getPrototypeOf(this) === _console ? _console : this;\n\n      for (var i = 0; i < args.length; i++) args[i] = arguments[i];\n\n      if (opts.serialize && !opts.asObject) {\n        applySerializers(args, this._serialize, this.serializers, this._stdErrSerialize);\n      }\n\n      if (opts.asObject) write.call(proto, asObject(this, level, args, ts));else write.apply(proto, args);\n\n      if (opts.transmit) {\n        const transmitLevel = opts.transmit.level || logger.level;\n        const transmitValue = pino.levels.values[transmitLevel];\n        const methodValue = pino.levels.values[level];\n        if (methodValue < transmitValue) return;\n        transmit(this, {\n          ts,\n          methodLevel: level,\n          methodValue,\n          transmitLevel,\n          transmitValue: pino.levels.values[opts.transmit.level || logger.level],\n          send: opts.transmit.send,\n          val: logger.levelVal\n        }, args);\n      }\n    };\n  }(logger[level]);\n}\n\nfunction asObject(logger, level, args, ts) {\n  if (logger._serialize) applySerializers(args, logger._serialize, logger.serializers, logger._stdErrSerialize);\n  const argsCloned = args.slice();\n  let msg = argsCloned[0];\n  const o = {};\n\n  if (ts) {\n    o.time = ts;\n  }\n\n  o.level = pino.levels.values[level];\n  let lvl = (logger._childLevel | 0) + 1;\n  if (lvl < 1) lvl = 1; // deliberate, catching objects, arrays\n\n  if (msg !== null && typeof msg === 'object') {\n    while (lvl-- && typeof argsCloned[0] === 'object') {\n      Object.assign(o, argsCloned.shift());\n    }\n\n    msg = argsCloned.length ? format(argsCloned.shift(), argsCloned) : undefined;\n  } else if (typeof msg === 'string') msg = format(argsCloned.shift(), argsCloned);\n\n  if (msg !== undefined) o.msg = msg;\n  return o;\n}\n\nfunction applySerializers(args, serialize, serializers, stdErrSerialize) {\n  for (const i in args) {\n    if (stdErrSerialize && args[i] instanceof Error) {\n      args[i] = pino.stdSerializers.err(args[i]);\n    } else if (typeof args[i] === 'object' && !Array.isArray(args[i])) {\n      for (const k in args[i]) {\n        if (serialize && serialize.indexOf(k) > -1 && k in serializers) {\n          args[i][k] = serializers[k](args[i][k]);\n        }\n      }\n    }\n  }\n}\n\nfunction bind(parent, bindings, level) {\n  return function () {\n    const args = new Array(1 + arguments.length);\n    args[0] = bindings;\n\n    for (var i = 1; i < args.length; i++) {\n      args[i] = arguments[i - 1];\n    }\n\n    return parent[level].apply(this, args);\n  };\n}\n\nfunction transmit(logger, opts, args) {\n  const send = opts.send;\n  const ts = opts.ts;\n  const methodLevel = opts.methodLevel;\n  const methodValue = opts.methodValue;\n  const val = opts.val;\n  const bindings = logger._logEvent.bindings;\n  applySerializers(args, logger._serialize || Object.keys(logger.serializers), logger.serializers, logger._stdErrSerialize === undefined ? true : logger._stdErrSerialize);\n  logger._logEvent.ts = ts;\n  logger._logEvent.messages = args.filter(function (arg) {\n    // bindings can only be objects, so reference equality check via indexOf is fine\n    return bindings.indexOf(arg) === -1;\n  });\n  logger._logEvent.level.label = methodLevel;\n  logger._logEvent.level.value = methodValue;\n  send(methodLevel, logger._logEvent, val);\n  logger._logEvent = createLogEventShape(bindings);\n}\n\nfunction createLogEventShape(bindings) {\n  return {\n    ts: 0,\n    messages: [],\n    bindings: bindings || [],\n    level: {\n      label: '',\n      value: 0\n    }\n  };\n}\n\nfunction asErrValue(err) {\n  const obj = {\n    type: err.constructor.name,\n    msg: err.message,\n    stack: err.stack\n  };\n\n  for (const key in err) {\n    if (obj[key] === undefined) {\n      obj[key] = err[key];\n    }\n  }\n\n  return obj;\n}\n\nfunction getTimeFunction(opts) {\n  if (typeof opts.timestamp === 'function') {\n    return opts.timestamp;\n  }\n\n  if (opts.timestamp === false) {\n    return nullTime;\n  }\n\n  return epochTime;\n}\n\nfunction mock() {\n  return {};\n}\n\nfunction passthrough(a) {\n  return a;\n}\n\nfunction noop() {}\n\nfunction nullTime() {\n  return false;\n}\n\nfunction epochTime() {\n  return Date.now();\n}\n\nfunction unixTime() {\n  return Math.round(Date.now() / 1000.0);\n}\n\nfunction isoTime() {\n  return new Date(Date.now()).toISOString();\n} // using Date.now() for testability\n\n/* eslint-disable */\n\n/* istanbul ignore next */\n\n\nfunction pfGlobalThisOrFallback() {\n  function defd(o) {\n    return typeof o !== 'undefined' && o;\n  }\n\n  try {\n    if (typeof globalThis !== 'undefined') return globalThis;\n    Object.defineProperty(Object.prototype, 'globalThis', {\n      get: function () {\n        delete Object.prototype.globalThis;\n        return this.globalThis = this;\n      },\n      configurable: true\n    });\n    return globalThis;\n  } catch (e) {\n    return defd(self) || defd(window) || defd(this) || {};\n  }\n}\n/* eslint-enable */","map":null,"metadata":{},"sourceType":"script"}